---
title: 'Miniproject 1: Open Sourcery'
---

# Introduction 

Welcome to the first Mini Project of BIOL 5380. The purposes of MP1 is to (1) become familiar with simple operations in the R computing language, (2) realize a little bit of the potential of scripting and scientific computing in context of biomechanics research, and (3) learn how to integrate analyses into . Hopefully, you've already downloaded both R and RStudio. Let's assume you have and we'll get right to it. 

# Part I: R Coding Basics

Now that we've been a little about R and its important properties, lets now explore how this knowledge can be put to use in the context of data and a workflow more typical in scientific reseach. For this project, we'll be looking at scale puncture data from Prof. Kenaley's lab. Briefly, these data come from experiments in which we used a motorized probe and force transducer to study how much force it takes to puncture fish scales from various locations on several species of fishes. The goal of analyzing these data is to assess if the magnitude of scale puncture resistance varies over the body and according to species. This data set is rather large (>1800 experiments!), but eminently suited for work in R (i.e., your head would spin trying to any of the following operations in Excel, say).  

# Set Up
Let's first download these data as .csv file from [this link](scales.csv). **Don't open the file in Excel** or some other program. If your OS does so automatically, just close the file without making any changes. The file in most cases will be automatically downloaded to a "downloads" directory (i.e., folder). Copy or move this file to a new directory, perhaps one named "scales" in a folder for this and other BIOL 3140 projects.

Open R Studio and create a new script (File->New->R script, see below). Save it (File->Save) with an appropriate title in your new "scales" directory. 

![FigName](newscript.png)
</center>
<br>

To this new R script, let's add our first lines of code. It's a general convention that we load the libraries of R packages that we want to use in the R session (i.e., when R Studio is running R). Without doing so, if you call functions that aren't loaded in base R, you'll encounter an error. For this project and script, we need `ggplot`, a handy plotting package and `tidyverse`, a collection of data analysis packages. Make sure you've installed them, something you should have done will reading and working with HOPR. These initial lines of code would look like this:

```{r,results="hide",warning=FALSE}
library(ggplot2)
library(tidyverse)
```


Go ahead and just copy and paste these line into your script at line 1.  Notice that when you do this nothing happens. Entering code, either by typing or pasting doesn't tell R to run it. **You must do so explicitly** by selecting a section of code you want to run (the first line in this case) and pressing "enter" or compiling the entire script by clicking on the "run" icon at the top of the R Studio screen. Hit "run" and see what happens. In the console tab at the bottom of R Studio, you'll see this:

![FigName](loadlib.png)
</center>
<br>

The console is where you see what's happening or has happened in the R session. Go to the console and type in `library(ggplot2)` and hit return. You've just asked R to load the `ggplot2` library, but because it's already loaded, you won't get any red text in response. Working in the console rather than running code line by line in the script or compiling the whole script can be handy, especially when you just want to do simple things that you don't want saved in the script. For instance, type `5000/3` into the console and hit return. Notice you get your answer: 1666.667.

Let's move on to another convention of writing an R script: setting the working directory. This is perhaps the most important step when working with external data in R (and doing so many other important tasks, like saving outputs from analyses, e.g., figures, tables, etc.). The working directory is a way of telling R where to find and save things. Without this input, R won't know where to find or place important objects like data or figures, respectively. 

<div class = "green">
<div class="row">
  <div class="col-sm-2"><a class="far fa-sticky-note fa-5x" style="color:#939681"></a> <!-- regular style --></div>
  <div class="col-sm-9">`setwd()` is a command essential to working in R. It's hard to overstate just how important this component of a script is. Over the years, in working with students learning how to use R, I come to have them recite the three most important rules for beginners:

  1. Always set the working directory!
  2. Never forget to set the working directory!
  3. Set the working directory always and forever!
</div>
</div>
</div>
<br>

To perform this all important task, we'll include a `setwd()` command. This function merely needs a text string that stipulates the path of the directory you want to work in. The path may look something like, "~/Chris/Documents/bc/3140/scales". **Note: This will be unique to almost everyone**, that is, we all have different naming conventions for our folders on our computers. My name is Chris, I have a documents folder that contains a "bc" directory, which contains a "3140" directory, which, in turn, contains the "scales" directory I want to work in.

At first, typing in the text of a path may be confusing and less than intuitive. If this is the case, there's a hack. In R studio, just click on "Session->Set Working Directory->Choose Directory" and, in the file browser window, select the directory you want to work in (say "scales" in this case) and press the "OPEN" icon. This will set the working directory to "scales". Notice that in the console, a `setwd()` command has been entered and run, complete with the file path. This file path will be the working directory for the script until you change it through the same approach or close R Studio. When you open your script in R Studio again, you'll have to set the directory again as well. To avoid this cumbersome step each time you start up R and R Studio, just copy and paste the `setwd()` command from the console into you script. Now your script should look something like the following but with your own unique directory path to the working directory:


```{r,eval=FALSE}
library(ggplot2)
setwd("~/Chris/Documents/bc/3140/scales")
```

Select these lines in your script and run them or click on "run". If all goes well you'll see these lines appear in the console without any errors. If you made some error in typing in the file path, then you'll get an error. For example, if I forget the trailing "s" in the "scales" part of the directory path as in this code, I would've gotten the following output:

```{r,error=TRUE}
library(ggplot2)
setwd("~/Chris/Documents/bc/3140/scale")
```

# Loading Data

OK, now that we've gotten our working directory set, we can now load the "scales.csv" file that was placed in the "scales" directory. 

```{r}
dat <- read.csv("scales.csv")
```

Here, the command `read.csv()` is used to read in the data and the results are passed to the variable named `dat`, short for data. By default, the results of reading in a .csv file with `read.csv()` are stored as a data frame, a two dimensional table-like object with rows and columns. Before we get to working with these rows and columns, let's first inspect what sort of data we have and say something about what they mean. 

One can see how large the data set is with `dim()` and reveal the first few lines of the data with the function `head()` :

```{r}
dim(dat)
head(dat)

```
Using the `dim()` function reveals that there are 1842 rows and 4 columns, while the `head()` command reveals that there are columns named "N", "quadrant", "species", and "specimen". You might simply want to run these lines in the console rather than from the script---if this is in the script, each time you run it, you'll get the the dimensions and first 5 lines of the data printed to the console. You really only need to do this once. 

The 1842 rows represent the results of puncture experiments on that many scales. The four columns represent the following: 

  + "N" is the force (in Newtons) it took the needle to puncture a scale 
  + "quadrant" indicates from where on the body the scale (see below):
    + "UL": Upper left of the body (anterodorsal quadrant)
    + "UR": Upper right of the body (posteroodorsal quadrant)
    + "LL": Lower right of the body (anteroventral quadrant)
    + "LL": Lower right of the body (posteroventral quadrant)
  + "species" indicates from which species the scales came
  + "specimen" indicates from which specimen the scales came (several for each species)
  
  ![FigName](quad.png)
</center>
<br>

Now let's see how these data are stored in R, that is, what class the columns are. We can do this one of several ways using the function `class()`. The first and most cumbersome would be to use the subsetting techniques we've learning in HOPR to evaluate each column. Remember that the `$` symbol or numbers reflecting column position (i.e., index) can be employed to retrieve specific columns. Something like this:

```{r}
#with "$"
class(dat$N)
class(dat$quadrant)
class(dat$species)
class(dat$specimen)
#with index, produces the same result
class(dat[,1])
class(dat[,2])
class(dat[,3])
class(dat[,4])
```

Here, using either method, we see that the "N" column is numeric (it's a continuous value corresponding to force), while all the other data columns contain factors, text strings to be exact, representing their discrete values for quadrant, species, and specimen. As you learned in HOPR, this means we must treat the numeric values differently than the factors and vice versa. Go ahead and try treating them the same:

```{r,error=TRUE}
mean(dat$N)
mean(dat$quadrant)
```

Notice that R tells you that mean can't be computed on "quadrant" because it is not numeric. 

OK, so now we've learned what classes of data we have, but we've done so in no fewer than four lines of code representing operations on each of the columns. The power or R and other programming languages is that there's almost always a faster and simpler way of doing things. In this case, we can inspect the class of out data in just one line using `sapply()`.

```{r}
sapply(dat,class)
```

Easy peasy with `sapply()`. Have a look at `?sapply()`, the help entry, which explains that this function applies another function over a vector. In the case of data frames, `sapply()` applies a functions over a vector of columns by default. This is considerably more tidy and speedy than subsetting columns and repeating procedures over each. 

<div class = "green">
<div class="row">
  <div class="col-sm-2"><a class="far fa-sticky-note fa-5x" style="color:#939681"></a> <!-- regular style --></div>
  <div class="col-sm-9">Whenever you get an error in R, the tendency is to go right back to the code and try to fix things, paying little attention to the red text in the console. Errors often tell you something very important about your script and, in this example, your data. Be sure to read these errors carefully and makes sense of them before altering your code. Googling the error is often a huge help.
</div>
</div>
</div>
<br>

# Simple Operations: Summarizing

Now that we know what sort of data and how much of it we have, let's do some simple operations that a biologist might perform ahead of any analysis. Consider what additional and important things we want to know about our data. How many species are in our data set? How many specimens per species were included? How many observations (punctures) are there for each species? Yes, Yes, and Yes. These and other questions about the make up of your data can be answered through summarizations.

Let's start with how many species we have. Because we're working with a character class for the species column, we first want to change that to a factor. As we've learned from HOPR, factors have levels,i.e., unqique values. This is exaclty what we want: to find the unique values for species. So let's convert this column to a factor, then we can inspect the levels. To change the column class to a factor and then reveal the levels in factor-type data, we simply redefine the column and then pass those data through `levels`:

```{r}
dat$species <- as.factor(dat$species)
species <- levels(dat$species)
species
```
By storing the levels of species and calling "species" on separate line, we see that there are 6 species in our data set. But let's have R tell us how many. We can count things in R with the `length()` function:

```{r}
length(species)
```

The names and number of species, revealed in two lines of code. Pretty simple. Now how about how many observations per species. This is often a crucial piece of summary information, i.e., are there 1800 observations for *A. rupestris* and just a handful for all the others? If so, this wouldn't be much of a comprehensive study across these species. Finding how many observations, as with previous operations, can be done in a number of different ways. And like these previous operations, let's consider both cumbersome and more straightforward methods. 

Because we have the levels (all unique values) of species stored, let's use that vector of names and some [logical-test operations we learned about in HOPR](https://rstudio-education.github.io/hopr/modify.html#logical-subsetting) to subset the data frame and the variable `species` and count the observations. Let's take on the first value of the `species` variable first. In the code below, all the values in the species column are compared to the first entry for "species" ("A. rupestris") by using `==`. This asks the question *Does the value to the left equal the value to the right?*  In this specific case, we use `==` to ask *Do the values in `dat$species` equal the first value in the "species" variable?* 

```{r,results='hide'}
dat$species==species[1]
```

Have a look at the result in the console (I'm not showing the output here, because . . .). You should see hundreds of logical values, `TRUE` and `FALSE` with many `TRUE`'s at first. This indicates that the first 300 or so values for the "species" column matches "A. rupestris". Now we can nest these logical values within the "species" vector (column) to return only those values that match "A. rupestris", like so:

```{r,results='hide'}
dat$species[dat$species==species[1]]
```

From here, we can find the length of this subsetted vector, save the results in a new variable name that resembles that particular level of "species", and then iterate through all the levels of "species". After this, let's combine the results in a data frame using our `species` variable and `c()` to combine our new length variables.

```{r}
A.rup<-length(dat$species[dat$species==species[1]])
L.gib<-length(dat$species[dat$species==species[2]])
L.mac<-length(dat$species[dat$species==species[3]])
M.sal<-length(dat$species[dat$species==species[4]])
M.sax<-length(dat$species[dat$species==species[5]])
P.fla<-length(dat$species[dat$species==species[6]])

#combine the results with species
species.obs <- data.frame(sp=species,n=c(A.rup,L.gib,L.mac,M.sal,M.sax,P.fla))
species.obs
``` 

There we have it, the number of observations/punctures for each species. Pretty evenly distributed, so not to worry about widely uneven sample sizes. This is great, but, this took many lines of code and some "hard coding", that is, explicitly inputting a value. The hard coding issue here is with typing in the numeric potion ("1", "2", "3", etc.) for each entry in our "species" variable. This is a drag and opens the door to mistakes. Why not let R do the iterations for you? 

As we're learning, summarizing data is an important step in any analysis. Fortunately, succinct methods and operations in R for summarizing exist in several popular packages. Perhaps the most widely used are those curated in "tidyverse", a set of R packages designed for data science. All the packages in tidyverse share an underlying design philosophy, grammar (what the functions looks like and ask for), and data structures, making it a one stop shopping experience for data analysis. We'll introduce how to summarize data using functions from tidyverse here and move on to more involved operations using tidyverse in the next module. Should should already have tidyverse installed and loaded.

tidyverse includes the `dplyr` package, a super helpful library of functions for data analysis. Let's use its `summarise()` and `group_by()` functions and pipe convention (`%>%`) to find the number of punctures per species. The `summarise()` function creates variables that summarize the data according to variables of interest. We set these variables of interest using `group_by()`. The pipe, `%>%`, is used to combine data with these functions. As we'll see in more detail later, the pipe `%>%` passes results from left to right.  Using the pipe with the data and the functions `group_by()` and  `summarize()`, we summarize our data by species rather succinctly. 

```{r}
dat %>%
  group_by(species) %>%
  summarise(n = n())
```
What this code essentially means is *pass the data through the function `group_by()`, grouping it by the "species" column, and summarize it according to group with a count, `n()`*. Notice the result is a tibble, a particular type of data object, akin to a data frame. We'll discuss tibbles more in the next module.

Of course, we can save these results to a variable.

```{r}
species.n<- dat %>%
  group_by(species) %>%
  summarise(n = n())
species.n
```

Now we haven't answered one of our questions, *How many specimens for each species?*. This, again is super easy with `dplyr` and the pipe. Here, we pass our data to a `count()` function that counts observations according to groups ("species" and "specimen" in this case), use `print()` so you can see the output, and then we count this output of observations by "species" to find the unique values of "specimen".

```{r}
dat %>% 
  count(species,specimen) %>%
  print() %>%
  count(species,name = "n.specimens")
```


<div class = "green">
<div class="row">
  <div class="col-sm-2"><a class="far fa-sticky-note fa-5x" style="color:#939681"></a> <!-- regular style --></div>
  <div class="col-sm-9">By now, you're head may be spinning like a top. This is a lot to take in. Don't worry! We're just running quickly through the basics and won't worry too much about committing any of this to memory. Just keep moving through this project, logging these operations in your R script, and you can always come back to specific parts when challenged by similar tasks in the future.
</div>
</div>
</div>
<br>

# Loop When You Can

Phew! You're almost there, the end of the Module 2 Project. Just one last important concept to work through, the loop, specifically, the `for` loop. This is a great device for iterating through operations for which there aren't dedicated functions. Important examples of this in the context of organismal biology include loading data from many files into one data set and producing a bunch of figures all at once from a large data set, among other things. Since we have a large data set loaded, why don't we use a `for()` loop to produce a bunch of figures.

A `for()` loop essentially tells R to do something over a set of things in a vector. For instance, for "i" in 1 to 10, print each  "i":

```{r}
for(i in 1:10) print(i)
```

In the context of doing something much more complicated, this saves a bunch of time. Back to our example of saving many figures from our large data set. Consider the case of plotting the mean puncture force for each quadrant in each species. This is easily accomplished with a short `for()` loop that works over our `species` variable and contains a filter, pipes, and a `ggplot()` operation.


```{r}
for(i in species){
  p <- dat %>%
  filter(species==i)%>%
 ggplot()+geom_boxplot(aes(x=quadrant,y=N))+ggtitle(i)
 print(p)
}
```

Here, for each value `i` in `species` we passed `dat` through a filter where `species==i`, plotted a boxplot using `ggplot` where x is the quadrant, y is the puncture force. For each species, this  got saved to `p` and then we printed `p`.  Notice that 6 separate plots are sent sequentially to the "Plots" tab in the lower right panel. This is where graphical results are shown in R Studio. No need to establish 6 separate pieces of code for each figure. 
  
Let's wrap this up by saving a PDF file containing all the figures.

```{r}
pdf("species.quadrant.pdf")
for(i in species){
  p <- dat %>%
  filter(species==i)%>%
 ggplot()+geom_boxplot(aes(x=quadrant,y=N))+ggtitle(i)
 print(p)
}
dev.off()

list.files(pattern=".pdf")
```


  
The wrapping function `pdf()` prints graphic output to a file, in this case one named "species.quadrant.pdf". Any plot printed with `p()` after `pdf()` and before `dev.off()` saves the plots in the named file. The `list.files()` command with `pattern=".pdf"`  confirms that a PDF file was saved to our working directory.

  
# Project Report

The goal of this project report is to submit an R script that runs the code presented above and produces the PDF of mean puncture force across each quadrant for each species. For the project to be complete, the script must include the following:
      
  1. A `dat` variable containing the scales dataset.
  2. A line of code which reports the class of each column in the dataset.
  3. A line of code which reports the dimensions of the dataset.
  4. Code that produces a summary of the number of scales punctured for each species.
  5. Code that produces a summary of the number of specimens sampled for each species.
  6. Code that produces a PDF file containing 6 figures, one for each species that includes a boxplot of puncture force verus quadrant. 
    
Have one representative of each team submit the code and PDF [here](https://forms.gle/GZotQwqzAFczb8pW9). Submissions are due by 11:59 PM on Sunday, September 13th.

<div class = "green">
<div class="row">
  <div class="col-sm-2"><a class="far fa-sticky-note fa-5x" style="color:#939681"></a> <!-- regular style --></div>
  <div class="col-sm-9">As a reminder, please check out the [Phase I projects rubric](phaseI_rubric.html) to get a sense of how this project will be assessed.</div>
</div>
</div>
</div>
<br>


First off, let's get some data. The file "`OZ_jumping_1.csv`" contains y displacement (in cm) of Prof. Kenaley's two kids jumping. These were digitized from high-speed videos. It can be dowloaded here: <http://www2.bc.edu/christopher-kenaley/bio5380/MP1/OZ_jumping_1.csv>. Let's then save it to a folder on you computer, i.e., a directory.

Let's now open up RStudio and open a new script file with "File -> New File". Give it a name and save it to the same directory the jumping data are in. Now, let's tell R that it needs to look for data in a particlar folder by setting the working directory: 

```{r}
#on a mac
setwd("~/Documents/BC/5380.s.2018/MP1")

#on a pc
#setwd("C:\\Users\\user\\Documents\\BC\\5380.s.2018\\MP1")
```

Note, this is unique to each user. You can pull up the file info with your operating system and copy the directory and paste it within quotes of the `setwd()` command. Select the line and run the the `setwd()` command. 

Now, let's load the data and check that it read with (remember, `<-` is R speak for pass the stuff to the right to a variable name on the left):

```{r}
dat <- read.csv("OZ_jumping_1.csv") #read the data from the comma-separated file 
head (dat) #print the first few rows to the monitor
```

OK, data loaded. Congrats! The `head()` command prints the first few rows, showing that the data include `o` for Ollie's data and `z` for Zoe's vertical displacement and `t` for time in milliseconds (ms), Now, let's plot some of the data, say for Zoe, with the simple graphics packages and `with()` command loaded with R. The `with()` call says, "R, with the data `dat`, plot a scatterplot of `z` versus `t`."

```{r, echo=FALSE}
with(dat,plot(t,z)) #the with command say do with x something
```

Splenid! But what about poor Ollie?!? We could add his points with the following `points()` call. The color parameter (`col`) is added with `red` to distinguish the two jumpers.

```{r}
with(dat,plot(t,z))
with(dat,points(t,o,col="purple"))
```

Even better! OK, but don't we want to know more about this experiment, like say who jumped highest? How would we answer that? Well, perhaps something like this would help:


```{r}
max.o <- max(dat$o)
max.z <- max(dat$z)

max.jump <- c(max.o,max.z)
names(max.jump) <- c("o","z")
print(max.jump)
```
`print()` prints something to the terminal and the `c()` command combines two or more things and the `names()` command gives a vector (a one-dimensional series) its names (notice the two must be the same length) 

So that's all well and good. It looks like Zoe jumped a littler higher. But, by how much? That's simple to calculate. To do this, we'll make turn these summary statistics into a two-dimensional data frame (like a spreadsheet), with the `data.frame()` function.

```{r}
oz.stats <- data.frame(o=max.o,z=max.z)
oz.stats$diff <- abs(oz.stats[,"o"]-oz.stats[,"z"])
print(oz.stats)
```


Notice how we are able to subset the data by column name with brackets. Within the brackets, anything to the right of a comma references columns and anything to the left rows. So we select columns that equal `o` and `z` and then take the absolute value of one subracted from the other with the `abs()` call. 


# Whole 'nutha level
Spectacular! However, it's a little cumbersome. There is, indeed, a little more streamlined way to do this with slightly more sophisticated data maniplulation and plotting that produces much more pleasing results and a workflow that can be manipulated with ease. Let's first install and then load some packages that make for easy data manipulation and wonderful plot making.

```{r}
#install.packages("ggplot2")
#install.packages("reshape2")
#install.packages("plyr")
library(ggplot2)
library(reshape2)
library(plyr)
```

Let's go back to the original data and melt it, that is, rather than have seperate columns for the vertical displacement data for `o` and `z`, let's have them in one and identify in another column to whom the data belong. This is super easy with the `melt()` function from `reshape2`. Then we can use the amazingly simple and beautiful plotting commands from `ggplot` to plot the data with a color according to the variable (which kiddo).

```{r}
dat.m <- melt(dat,id= "t")
head(dat.m)
tail(dat.m)

qplot(x=t,y=value,dat=dat.m,col=variable) #a quick plot with ggplot
```

Super easy and concise. What about those summary statistics? Just as easy with the `ddply` function in the `plyr` package . . . 

```{r}
dat.sum <- ddply(dat.m,.(variable),summarize,max=max(value),min=min(value),max=max(value),n=length(value))
head(dat.sum)
tail(dat.sum)

qplot(x=variable,y=max,dat=dat.sum,col=variable,size=4)
```

# Loop `if` you can

One of the most magical aspects of command-line computing (i.e., what you're doing right now) is that one can automate the mundane. Imagine that instead of just one jumping experiment, you ran 5 separate jumping expirements with these two goofballs and had digitized data from each. Now that's 5 replicates and worthy of some comprehensive analysis. For the record, 5 is generally seen as the magic minimum number of replicates in biomechanics. Assuming all the replicates result in the same raw data---vertical displacement of `o` and `z` and `t` in milliseconds, this should be relatively straigtforward. Think for a moment about how you would go about this. Would you somehow get these data into Excel and add another column column indicating the replicate? You could do that, but that's slow and, as with so many manual operations in computing, often results in errors. Due to these factors and, as importantly, the ethos of BIOL5380, let's avoid using commercial software with all its limitations. But where to begin? Enter the `for` loop. 

What is a `for` loop you ask? It's a command that runs while a condition is satisfied. For example, how 'bout we print a count down thusly:

```{r}
cnt <- 10:1 #store some numbers

for(i in cnt){
  print(paste("It's now", i))
}

```

The operations contained in the `for` command (within the `"{ }"`) are repeated through the series defined by `cnt`. Specifically, for each value in `i`, `paste()` together `"It's now"` and `i` and `print()` it.

Now that we have a basic understanding of how this works, let's apply it to our problem: automating the combining of a bunch of data. The crux here is that each of our 5 jumping trials are contained in their own files. Go ahead and download the remaining files and move them to your working directory:

<http://www2.bc.edu/christopher-kenaley/bio5380/MP1/OZ_jumping_2.csv>

<http://www2.bc.edu/christopher-kenaley/bio5380/MP1/OZ_jumping_3.csv>

<http://www2.bc.edu/christopher-kenaley/bio5380/MP1/OZ_jumping_4.csv>

<http://www2.bc.edu/christopher-kenaley/bio5380/MP1/OZ_jumping_5.csv>

Now have a look at your files in the directory with this: 


```{r}
list.files()

```

Notice something about the file name structure? They are all named with a simple convention, that is, they all end in `_number.csv.` This number indicates the replicate (1 was the first, 5 was the last). With a standard convention like this, we can use a `for` loop to read in each file and extract from the file name from what replicate the data come. Let's walk through it. First, store the file names of interest:

```{r}
dat.files <- list.files(pattern=".csv")

```

This saves the names of all the files with the pattern `.csv` to the variable name `dat.files`. Now, let's use the for loop to read each file and save it to a list of data frames. 

```{r}

all.dat <- list() #establish an empty list
for (i in dat.files ){
  meta.dat <- strsplit(i,"_")[[1]] #store the metadata by splitting the file name
  if(grepl("OZ",i)) print("YES") 
  rep <- gsub(".csv","",meta.dat[3]) #use grep commands to remove the ".csv" at the end
  dat.i <- read.csv(i) #read in the data
  all.dat[[i]] <- data.frame(dat.i, rep=rep) #combine the data withe replicate number in a data frame and stor it in our list under the file name i
}
```

Phew, that was a lot, let's unpack it. The first line establishes a list named `all.dat` to receive our data. Then, the guts of `for` ensues. For all the `dat.files`, first retrieve the meta data, i.e., the data that explains your data, in this case the replicate number. We do this with the `strsplit()` command. It splits a text string by seperator, a `"_"` in this case. Notice that the command `strsplit(i,"_")` outputs a list itself. The tell here is the `[[1]]`, a "1" with the double brackets indicating such.

```{r}
strsplit(i,"_")
```

There's only one element in this list, but we still have to identify that's the one we want. Thus the `[[1]]` added to the `strsplit(i,"_")` command. Notice the third element in this is what we want, the replicate number. However, it has the unsightly "`.csv`" stuck to it. Let's zap that with a `gsub()` command. `gsub()` is one of a series of search commands common to all computing languages. These commands use  general regular expressions, or `regex`, in algorithms to find text. It's really powerful, but any in-depth explanation of how they work is way beyond the scope of this MP and the course (however, you can learn more [here](https://en.wikipedia.org/wiki/Regular_expression). `gsub()` finds a string and substitutes it with another. In our case, we want to find `".csv"` and replace it with `""`, that is, nothing. With `gsub(".csv","",meta.dat[3])` we do just this and store the result in `rep`.

Next, we read in the data and pass it to the variable `dat.i`. Then, we combine the data in a data frame with a new column called `rep` with the `rep` meta data. This gets passed to an item in the list `all.dat` with the name `i`. This proceeds for all the items in the `dat.files` variable. Viola! Now we have a list of named data frames. Have a look by typing `all.dat` into the terminal. Caution: R tries to print it all.


What's left is to simply combine all the data frames into a single data frame.

```{r}
all.dat <- do.call(rbind,all.dat)
```

What we did here is apply a function to all items in our list with the `do.call()` command. This says, "Bind the rows of all the data frames in the `all.dat` list with the command `rbind`." Double viola!! Have a look by printing the first few and last few rows of the new comprehensive data frame.

```{r}
head(all.dat)
tail(all.dat)
```

Wow, all our data from the five replicates in one spot. Now, we can apply some of the manipulation techniques we learned above to derive some summary statistics. So say we want to know the minimum, maximum, and number of data for each trial and for each kiddo:

```{r}
all.m <- melt(all.dat,id=c("rep","t")) #first melt the data frame
all.sum <- ddply(all.m,.(rep,variable),summarize,min=min(value),max=max(value),n=length(value)) #summarize the data by rep and variable (kiddo) and extract the min, max, and length (n)
```

Sweet! Easy peasy. Let's plot our results---the max vertical displacement---but this time save the plot itself to a variable `p`.

```{r}
p <- qplot(x=rep,y=max,dat=all.sum,col=variable)
print(p) #print p to see it
```

After saving the plot, we can add aspects to it using the `ggplot` language. For example, change the x- and y-axis labels and give the plot a clean, classic look with 20 pt font. Then, save the plot as a PDF:


```{r}
p <- p+ylab("y displacement (cm)")+xlab("time (ms)")+theme_classic(20)

pdf("y_disp_vs_t.pdf") #open a pdf
print(p) #print a plot to it
dev.off() #shut it down
```


Holy smokes, that looks spectacular! You're now armed with some kick-arse scripting and plotting skills to analyze and visualize data, biomechanical or otherwise.

# Your mission (and you have to accept it)

Now that you have some R skills, lets put them to the test. You're tasked with writing a markdown document using `knitr` in much the same way this document was produced. Yes, I'm throwing you to the wolves, but that's often what makes this stuff stick. You can start with details on using R Markdown at http://rmarkdown.rstudio.com **and** inspecting the contents of this file. This'll help, too: https://www.rstudio.com/wp-content/uploads/2015/02/rmarkdown-cheatsheet.pdf

The markdown must contain the following:

  1. A plot of the mean maximum for each kiddo across all replicates. It must contain or be accompanied with:
    + properly labelled axes
    + different colors for each subject
    + error bars that correspond to 1± standard error of the mean (s.e.)
    + a simple ANOVA test of results (with alpha of 0.05). [This'll help.](https://www.statmethods.net/stats/anova.html)
    + a brief paragraph summarizing the differences and any inferences of why they are
  2. A plot of the maximum vertical displacement for each kiddo versus replicate with a trend line. This must also be accompanied: 
    + a table and summary of a two-way ANOVA (i.e., analysis of covariance) that tests the differences between subjects as they vary with replicate. [This'll help.](https://rexplorations.wordpress.com/2015/09/07/two-way-anova-in-r/)
    + a brief paragraph summarizing the differences and any inferences of why they are
    
The `knitr` markdown file is due on January 29th at 11:00 Am. You should submit the file to this [google directory](https://drive.google.com/drive/folders/1XnpBl1sx1DJFnEq_ngMZIdUmEySCa-nZ?usp=sharing) by the start of class. 
  
  <b>Good luck!</b>

# Introduction

Now that we've learned (at breakneck speed!) some ins and outs of data analysis, visualization, and modeling, we'll turn to how a scientist can easily organize, share, and communicate results and ideas. Communication of the results of any research in science is, at its final stage, usually done through publishing scientific papers. However, before this final product, scientists must catalog the maturation of their work and often seek to repeatedly share it with collaborators. Cataloging the progress and sharing preliminary results can take many forms: exchanging scripts that analyze data, giving presentations to colleagues, and passing manuscripts back and forth between team members, just to name a few activities. 

From a mechanistic standpoint, the workflow for sharing progress is often decentralized. Want to share scripts? Send the over email or store them in cloud (or GitHub!). Want to give a presentation? Import figures from your scripts into a slide deck. Want to create and share a manuscript? Write it up in a word-processing software and distributed over email or the cloud. Fortunately, there exists a unifying alternative: markdowns, an easy-to-read and easy-to-write plain text format that's then converted to any one of a variety of formats (slides, PDF, HTML, etc.). For we scientists working in R, we can use R Markdown, giving us the added benefit of adding code and the results of our code to text and commentary about our work. It's one stop shopping.

In this project, we'll learn the basics of R Markdown. Specifically, we'll learn how to author documents that include code, the graphics that are produced from it, and stylistically pleasing text that place the results of our analysis in context.

Our tasks will be to:

  1. Familiarize ourselves with the R Markdown framework.
  2. Author a simple R Markdown.
  3. Run code within an R Markdown document.
  4. Add graphics (i.e., figures), images, tables and references to and R Markdown document. 
  5. Render (i.e., knit) this R Markdown into HTML and PDF documents.

# Set up

First of all, let's precisely define what we mean by a markdown, the syntax for R Markdown. Markdown is a very simple ``markup" language which creates documents with headers, images, references, pieces of code and so much more from plain text files. Because it's text based, the document can be rendered into many other file formats like HTML or PDF that will contain the organized content.

To get R Markdown up and running, you don't need to do much at all if you're using R Studio. You just need to open a new markdown document: "File->New File->R Markdown". This will open a dialog where you are asked to include important pieces that will specify the document type, and author and title of the document. 

![](newRmd.png)
<br>

Enter in a title ("Project 4", is just fine) and the author (your team name is great, e.g., "aRtful coders"). Select "OK". Now, this doesn't save the new .Rmd, but rather establishes the author and title in the YAML header (more below). You should see that the document is now open in a tab with the name "Untitled1.Rmd". Go ahead and save this with the name "TEAMNAME_Module4" in an appropriate directory. The ".Rmd" extension informs R Studio that this is a source file for markdown and thus it will treat it as such. 

<div class = "green">
<div class="row">
  <div class="col-sm-2"><a class="far fa-sticky-note fa-5x" style="color:#939681"></a> <!-- regular style --></div>
  <div class="col-sm-9">

In R4DS, you may have noticed a discussion about the difference between R Markdown and R Notebooks. Notebooks are merely more compact version of R Markdowns. R Notebooks permit direct interaction with R while producing a reproducible document. However, any R Markdown document can be used as a notebook, so we'll bypass R Notebooks for now, and focus on R Markdowns.

</div>
</div>
</div>
<br>

Keep this document open and ready to edit. But, before was start, let's establish the context for authoring an R Markdown. Say, thinking back to the [Module 3 Project](mod3_proj.html), we wanted to report on some of our results, how we came to them, and what they mean. In that project, we found that ecomorph was an important predictor of the hindlimb-SVL relationship in anoles. Specifically, we used phylogenetic least squares analysis to assess this relationship under Brownian motion and OU models of trait evolution.

To assemble such a report, we should include sections that reflect the the progression of the analysis, each containing text, figures, captions, and references. Our sections should include an introduction, methods, results, discussion, author contributions, and a bibliography. Our tasks for this project will be taken on in this context: producing a succinct and reproducible report on the analysis of anole hindlimb evolution. Let's get started.

# Resources

As you learn more about R Markdown, you may want to reference the following online resources:

  * A rather [complete guide to R Markdown by Yikui Xie](https://github.com/rstudio/bookdown)
  * R Markdown [Cheatsheets](https://rmarkdown.rstudio.com/lesson-15.html)
  * R Studio's [markdown tutorial](https://rmarkdown.rstudio.com/)
  
# The YAML Header

You'll see at the top of your new ".Rmd" file a header contained between two lines (`---`). This is the YAML header that specifies the the attributes of the markdown, all of which are inherited from the dialog your answered when opening the new .Rmd. By default it includes a title, author, date, and type of file for your output. These are but a few of the formatting options and settings that could apply to the whole document. For now, let's leave it as is. So it should look like this:


```
---
title: "Project 4"
author: aRtful coders
date: 22/Sep/2020
output: html_document
---
```

Below the YAML header is the space where you'll include text, code, etc. 

# knitting Cozy Report

In the .Rmd before us, we have a template with some marked up text. This is the file that will be interpreted by the markdown language to produce a document. To do so, you must "knit" the .Rmd. You can do this by selecting the "knit" icon at the top of the file panel or keying in "cmd+shift+k". Go ahead and do either and see what happens. You'll get an HTML rendering of your document. You may end up doing this often as you add new pieces and markup to the text. Notice that there's now an .html file saved to the same directory containing the .Rmd file.

# Set the Working Directory No More

You may have noticed that we haven't yet set a working directory. In R markdown, this is unneeded and, frankly, discouraged. It's assumed that **all the things you need to knit your document are in the same directory as the .Rmd file**. We'll be running the same code from Project 3 in this .Rmd, so make sure all the data files from Project 3 reside where you have your .Rmd saved.


# Headers

When you start putting together the content of an .Rmd, you should consider adding sections almost immediately. This can serve as an outline for the document. Headers provide a way of hierarchically organizing the document into sections that reflect an outline. These are identified in the markdown by using one or several `#`. The more you use, the smaller the text and, presumably the less inclusive the header. That is, `#` is the biggest header and `##` is typically nested within a `#` header, and `###` is nested within a `##` header. For instance, this 

```
# Header 1

Text under Header 1

## Header 2

Text under Header 2

### Header 3

Text under Header 3

```
will produce this:

![](headers.png)


In your future project reports for Phase II and III of the class, you'll always want to include sections for an introduction, methods, results, discussion, author contributions, and references. We'll organize the .Rmd accordingly, so please add those sections to your .Rmd. with a high-level header `#`.  We'll add nested subsections and text later.  


```{r "load the data",include=FALSE,echo=FALSE}
library(tidyverse)
library(ape)
library(nlme)
library(MuMIn)
library(geiger)
library(knitr)
library(kableExtra)
library(rmarkdown)

anole <- read_csv("anole.dat.csv")
anole.eco <- read_csv("anole.eco.csv")
anole.tree <- read.tree("anole.tre")

anole2 <- anole%>%
left_join(anole.eco)%>%
  filter(!Ecomorph%in%c("U","CH"))%>%
  na.omit()

anole.log <- anole2%>%
  mutate_at(c("SVL", "HTotal","PH","ArbPD"),log)


### phylogenetic GLS models

#PGLS under BM, no ecomorph
pgls.BM1 <- gls(HTotal ~SVL, correlation = corBrownian(1,phy = anole.tree,form=~Species),data = anole.log, method = "ML")

#PGLS under BM, w ecomorph
pgls.BM2 <- gls(HTotal ~SVL * Ecomorph2, correlation = corBrownian(1,phy = anole.tree,form=~Species),data = anole.log, method = "ML")


#PGLS under OU, no ecomorph
pgls.OU1 <- gls(HTotal ~SVL * Ecomorph2, correlation = corMartins(0,phy = anole.tree,form=~Species),data = anole.log, method = "ML")

#PGLS under OU, w, ecomorph
pgls.OU2 <- gls(HTotal ~SVL * Ecomorph2, correlation = corMartins(0,phy = anole.tree,form=~Species),data = anole.log, method = "ML")

#AIC operations
anole.phylo.aic <- AICc(pgls.BM1,pgls.BM2,pgls.OU1,pgls.OU2)
anole.phylo.aicw <- aicw(anole.phylo.aic$AICc)

anole.phylo.aicw%>%
  kable(caption = "AICw of PGLS")

#add phylo-corrected residuals
anole.log <- anole.log%>%
  mutate(phylo.res=residuals(pgls.BM2))

#5
#plot residuals
p.eco.phylo <- anole.log%>%
ggplot(aes(x=SVL,y=HTotal,col=Ecomorph2))+geom_point()

print(p.eco.phylo)

#plot residuals
p.eco.phylo <- anole.log%>%
ggplot(aes(x=Ecomorph2,y=phylo.res)) +geom_boxplot() +stat_summary(fun=mean, geom="point", size=3)

print(p.eco.phylo)

```

# Adding Code with Chunks

Code you include in your .Rmd should be written in sections enclosed by three backwards apostrophes (```). These sections are known as code chunks and look like this:


<pre><code>```{r}
x<-1:100
mean(50)
```</code></pre>


You can insert code chunks with by selecting the "insert" icon at the top of the the tab or my keying in "command+option+i". 

<center>

![](insertchunk.png)

</center>

To run the chunk, your can  click on "run" tap and selection "Run Current Chunk" or insert your cursor in the chunk and key in "command+shift+return". 

<center>

![](runchunk.png)

</center>

The content inside the curly brackets (`{}`) controls the behavior of code chunk. In this case, we're telling R markdown that the code inside the chunk is to be interpreted with R. This is a handy place to control the output of the code chunk. Let's jump right into how you would include code in chunks from our relavent anole project. 

At first, you'll want to include a chunk that loads the libraries you intend to use in the .Rmd. This can be added to the very top of the document. Something that looks like this:

<pre><code>```{r,include=FALSE}
library(tidyverse) #always
library(ape) #for evo analysis
library(nlme) #ditto
library(MuMIn) #for AIC
library(geiger) #for eco analysis
library(knitr) #for knitting options
```</code></pre>

Notice here that we included a behavior to the chunk, specifically  `include=FALSE`. This prevents the code, and the results from appearing in the finished file. Have a look at [this page](https://rmarkdown.rstudio.com/lesson-3.html) to familiarize yourself with handy and often used chunk options.

With a few exceptions, the logical place to include the code that produces analyses or figures is in the results sections. This is where the first output of the code will likely be relevant. So, under the results section, insert the following code chunks that establish the data we need and performs the initial analysis for PGLS.


<pre><code>```{r, "load the data"}
anole <- read_csv("anole.dat.csv")
anole.eco <- read_csv("anole.eco.csv")
anole.tree <- read.tree("anole.tre")
```</code></pre>

<pre><code>```{r, "join, filter, mutate to log"}
anole2 <- anole%>%
left_join(anole.eco)%>%
  filter(!Ecomorph%in%c("U","CH"))%>%
  na.omit()

anole.log <- anole2%>%
  mutate_at(c("SVL", "HTotal","PH","ArbPD"),log)
```</code></pre>

<pre><code>```{r, "PGLS models"}
### phylogenetic GLS models

#PGLS under BM, no ecomorph
pgls.BM1 <- gls(HTotal ~SVL, correlation = corBrownian(1,phy = anole.tree,form=~Species),data = anole.log, method = "ML")

#PGLS under BM, w ecomorph
pgls.BM2 <- gls(HTotal ~SVL * Ecomorph2, correlation = corBrownian(1,phy = anole.tree,form=~Species),data = anole.log, method = "ML")

#PGLS under OU, no ecomorph
pgls.OU1 <- gls(HTotal ~SVL * Ecomorph2, correlation = corMartins(0,phy = anole.tree,form=~Species),data = anole.log, method = "ML")

#PGLS under OU, w, ecomorph
pgls.OU2 <- gls(HTotal ~SVL * Ecomorph2, correlation = corMartins(0,phy = anole.tree,form=~Species),data = anole.log, method = "ML")
```</code></pre>

<pre><code>```{r, "AIC"}
#AIC operations
anole.phylo.aic <- AICc(pgls.BM1,pgls.BM2,pgls.OU1,pgls.OU2)
anole.phylow.aicw <- aicw(anole.phylo.aic$AICc)
```</code></pre>

<pre><code>```{r, "add residuals"}
#add phylo-corrected residuals
anole.log <- anole.log%>%
  mutate(phylo.res=residuals(pgls.BM2))
```</code></pre>

  
<pre><code>``{r,"plot residuals", fig.cap="Boxplot of phylogenetically corrected hindlimb residuals versus anole ecomorph"}
#plot residuals
p.eco.phylo <- anole.log%>%
ggplot(aes(x=Ecomorph2,y=phylo.res)) +geom_boxplot() +stat_summary(fun=mean, geom="point", size=3)

print(p.eco.phylo)

```</code></pre>

Notice that for each chunk, we included some text in quotes. This identifies the chunk with a name or label, as R Markdown calls it. Each name must be unique. These names are useful especially when we render the document and any errors or warnings emerge. More on that later. 

Also notice that this last chunk named "plot residuals" has another parameter, `fig.cap`. This specifies a caption to produce under a figure produced from the chunk. In communicating result through visualizations, figures or otherwise, it's **essential that you include a description** caption. The caption should include what's going in the figure (e.g., type of plot, the axes, where the data come from). 

# Modifying Text

The basic syntax of a markdown language, so oddly named, is formulated around mark up. This is similar to other mark up languages like HTML or XML in that it uses tags to define elements within a document. There are many often used tags that you should be familiar with and most can be found in this [R Markdown cheatsheet](https://rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf). Let's consider the text in first paragraph of the introduction to the [Module 3 Project](mod3_proj.html#Introduction) description in block quotes below.


>The central theme of this project will be to assess the morphological and allometric differences between ecomorphs within the genus *Anolis*. First coined by the famous evolutionary biologist and herpetologist Ernest Williams, the term ecomorph describes a group of species, perhaps not sharing a most recent common  ancestor, with a similar ecological niche and behavior within the context of this niche. His model for this concept was the genus *Anolis*, although the ecomorph construct has been widely applied to many other species (think reef fish and Darwin's Finches). 

<center>

>![An anolis lizard](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)

</center>

>Our tasks will be to:

 > 1. Visualize how hind limb length varies with size (i.e., allometry!).
>  2. Visualize and asses how hind limb length vs. size relationship covary with ecological niche.
>  3. Learn more complex operations in `ggplot` than we've undertaken so far. 
 >  4. Evaluate this hindlimb-size relationship using standard frequentist models within and without a phylogenetic context.
 >  5. Using an information theory approach, assess the fit of phylogenetically corrected models of hind-limb variation under different modes of character evolution.

## Basic Formatting

Notice that there are several pieces of text that have unique formats.  For instance the genus *Anolis* is italicized. This is accomplished by wrapping the text with `*` or `*Anolis*`. You could, just as easily, bold text with `**`, `**Anolis**` to produce **Anolis**. 

As you've probably noticed in reading markdowns so far, where any code and names of code are written inline  (i.e., not in a chunk), the convention is to outline it with a distinctive background (usually gray). To do this, code-bearing text is wrapped in <code>&grave;&grave;</code>. So <code>&grave;ggplot&grave;</code> becomes `ggplot`.

## Ordered Lists

We can easily include lists in an .Rmd with simple mark ups. A numbered list is as simple as . . . 

```
  1. Visualize how hind limb length varies with size (i.e., allometry!).
  2. Visualize and asses how hind limb length vs. size relationship covary with ecological niche.
  3. Learn more complex operations in `ggplot` than we've undertaken so far. 
  4. Evaluate this hindlimb-size relationship using standard frequentist models within and without a phylogenetic context.
  5. Using an information theory approach, assess the fit of phylogenetically corrected models of hind-limb variation under different modes of character evolution.
 ```
 
 And this will produce what you see above. If you'd prefer a bulleted list, take this approach:

```
  * Visualize how hind limb length varies with size (i.e., allometry!).
  * Visualize and asses how hind limb length vs. size relationship covary with ecological niche.
  * Learn more complex operations in `ggplot` than we've undertaken so far. 
  * Evaluate this hindlimb-size relationship using standard frequentist models within and without a phylogenetic context.
  * Using an information theory approach, assess the fit of phylogenetically corrected models of hind-limb variation under different modes of character evolution.
 ```

This will produce the following:

  * Visualize how hind limb length varies with size (i.e., allometry!).
  * Visualize and asses how hind limb length vs. size relationship covary with ecological niche.
  * Learn more complex operations in `ggplot` than we've undertaken so far. 
  * Evaluate this hindlimb-size relationship using standard frequentist models within and without a phylogenetic context.
  * Using an information theory approach, assess the fit of phylogenetically corrected models of hind-limb variation under different modes of character evolution.

 
Notice the list elements are indented and the text separated by `*` with and empty space.


## Links
While no links are included in the example above, they abound in this and many other .Rmd documents. Inserting them couldn't be easier. One just has to wrap the text in brackets followed by the link path in parentheses. For example,  `[class site](https://bcorgbio.github.io/class/)` gives us [class site](https://bcorgbio.github.io/class/), text linking us to our class site.


## Images
We also have an image inserted above. Inserting images can be useful for all sorts of reasons, especially when you'd like to include a graphic that is not produced by R and resides elsewhere, like say online. The image above is inserted with:

```
![An anolis lizard](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)
```

Notice this is much like inserting a link, but we have to tell R markdown to stop interpreting text by including `!` before a set of brackets, then we include the file path (in this case, a URL). This is the simplest way to insert an image. But, say you want to include an image that is a live link as well. All you have to to is include the link tags around the image tags, like this: 

```
[![An anolis lizard](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)
```
<br> 

And this is what you'll get:

[![An anolis lizard](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)
<br>

This image isn't centered on the page. The easy way to modify the position of an image (or any element, really) is to use standard HTML tags. So wrapping `<center>` and `</center>` around our image code like so . . . 

```
<center>
[![An anolis lizard](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)
</center>
```

. . . gives us: 

<center>
[![An anolis lizard](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)
</center>

<br>

Keep in mind that R markdown prefers .jpg or .png images.

Of course, one can also add local images, i.e., those stored on your computer. For instance, say we wanted to include a small version of the radiograph image from the [Module 3 project Description](mod3_proj#Introduction), a .png stored in the same directory as this .Rmd file, we simply write

```
<center>
![](svl_small.png)
</center>
```

<center>
![](svl_small.png)
</center>
<br>

## Equations

As scientists, we often need to express our ideas in equation form (e.g., linear model of hindlimb vs. snout-vent length in case of our last project). Fortunately, this is made easy by R Markdown's inclusion of another markup language, $\LaTeX$. This is a favorite of those writing really technical documents and the equation markup capabilities are rather extensive but eminently approachable. For instance, if we need to write out an equation that expresses a linear model (e.g. `lm(y~x)`) we can write `$$y=\alpha+\beta x$$` to produce:

$$y=\alpha+\beta x$$

Notice the equation is wrapped by two `$$`. A single `$` indicates the use of $\LaTeX$ markup and two indicates the equation should stand alone on a separate section. If we just wanted to include the aforementioned equation inline with the rest of the text, we'd use just one `$`, or ``$y=\alpha+\beta x$` to get $y=\alpha+\beta x$.


<div class = "green">
<div class="row">
  <div class="col-sm-2"><a class="far fa-sticky-note fa-5x" style="color:#939681"></a> <!-- regular style --></div>
  <div class="col-sm-9">
Although it may appear as a coding free-for-all, the ability to include HTML and $\LaTeX$ markup in addition to R markdown language injects enormous flexibility. One can use all the standard methods of HTML and $LaTeX$ wizardry to expand R Markdown's capabilities and charm. These note boxes, for example are a container class written in HTML.
</div>
</div>
</div>
<br>


# Tables

Tables are often important devices in communicating something about your project. Sometimes your want tables populated with your data and code, others we need to create them by hand. 


## Tables From Code

For smallish tables generated from your code, I suggest the `kable()` function from the `knitr` package which is included with R Studio. It's simple and rather intuitive to use. For instance, let's say we wanted to know how many species were include in each ecomorph for our anole study. We'd first write the code to do so and then with the pipe, finally pass it to the `kable` function:

```{r,message=FALSE}
n.spec <- anole.log%>%
  group_by(Ecomorph2)%>%
  summarise(n.species=n())

n.spec%>%
  kable()
```
<br>

One nice attribute about `kable()` is that we can easily specify a table caption. Something like:

```{r}
n.spec%>%
  kable(caption = "Number of species within each anole ecormorph included in this study")
```
<br>

For large tables, say data sets with a large number rows, you may want to consider using the `paged_table()` function from `rmarkdown` to create a table that has pagination of rows and columns. For example:

```{r}
paged_table(anole.log, options = list(rows.print = 15))
```

Here we also added a parameter to `options` to print 15 row at a time.


## Tables "By Hand"

You can also define tables explicitly using markdown. For this, we merely mark up the text with `-` to specify the header and `|` to specify rows. So this . . . 


```
|    Ecomorph        | Description                             |
|------------------|-------------------------------------------|
| crown-giant     | Large bodied, lives in crown               |
| grass-bush      | Lives in grass or bushes                   |
| trunk           | Lives on the trunk                         |
| trunk-crown     | Lives in the trunk-crown interface         |
| trunk-ground    | Lives in the trunk-ground interface        |
| twig            | Lives out on the twigs of trees             |
```
becomes this:

|    Ecomorph        | Description                             |
|------------------|-------------------------------------------|
| crown-giant     | Large bodied, lives in crown               |
| grass-bush      | Lives in grass or bushes                   |
| trunk           | Lives on the trunk                         |
| trunk-crown     | Lives in the trunk-crown interface         |
| trunk-ground    | Lives in the trunk-ground interface        |
| twig            | Lives out on the twigs of trees           |


# Inserting References

As we prosecute out projects in Phase I and II, we'll be reading scientific papers, some assigned, some asked to find so that we can place our results in context. In addition, as scientists, we always want to support our statements of fact with references. For this,  we'll need to cite and include these papers in a bibliography. 

[Adding reference to an .Rmd](https://rmarkdown.rstudio.com/authoring_bibliographies_and_citations.html) is pretty straight forward. First we'll need to establish a .bib file that will reside in the same directory as your .Rmd file. To do this, select "File->New File->Text File." A new tab will appear with the name "Untitled1.txt". Save this file as "BIOL2140.bib" (note the ".bib" extension) in the same directory as your .Rmd file. This .bib file will be referenced by your .Rmd when inserting citations. 

The framework for citations and references in .Rmd can be formulated around [BibTex](https://en.wikipedia.org/wiki/BibTeX). BibTex is handy because you can find BibTex formatted citations in all your typical outlets (see note below). This system of citation uses a .bib file that contains text describing published works. Each work or potential reference in the .bib file is identified with a unique tag at the top of its entry and this entry contains the important bibliographic information. For instance, a .bib file containing a reference to the following paper

Hagey, T.J., Harte, S., Vickers, M., Harmon, L.J. and Schwarzkopf, L., 2017. There’s more than one way to climb a tree: Limb length and microhabitat use in lizards with toe pads. [PloS one, 12(9), p.e0184641](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0184641).

would have the following text:

```
@article{hagey2017there,
  title={There’s more than one way to climb a tree: Limb length and microhabitat use in lizards with toe pads},
  author={Hagey, Travis J and Harte, Scott and Vickers, Mathew and Harmon, Luke J and Schwarzkopf, Lin},
  journal={PloS one},
  volume={12},
  number={9},
  pages={e0184641},
  year={2017}
}

```

Notice we have a tag `&#64;article{hagey2017there,". This identifies the entry as a journal article (as apposed to a book or manual, etc.) and contains a key that is unique among all the other references in the .bib file. After this, the entry then goes on to identify the important bibliographic pieces: title, author, journal, etc.). Go ahead and add this BibTex reference to your BIOL3140.bib file and save it. 

For .Rmd to reference this .bib file, we need to specify a bibliography file in the YAML header. So now alter your YAML header at the top of the .Rmd so that it contains `bibliography: BIOL3140.bib". The YAML header should now look like this:


```
---
title: "Project 4"
author: aRtful coders
date: 22/Sep/2020
output: html_document
bibliography: BIOL3140.bib
---
```

With a .bib file now in place, we can use the reference keys to cite works listed in the .bib file. For this, we simply add the key label to the text with '@'. For instance, `@hagey2017there` with produce @hagey2017there. 

When citing published works in text, we often follow certain formatting conventions. To be honest, your professor couldn't care less about which format gets used in your .Rmds. Fortunately, R Markdown uses a familiar [Harvard-like](https://www.citethisforme.com/harvard-referencing) format by default and he recommends plowing ahead with it. In a Harvard-like format, a reference in a sentence used in an explicit manner, includes the reference year in parentheses. For instance, if we were to express that these authors studied the hindlimb-ecomorph relationship in anoles, we would write, "@hagey2017there studied the hindlimb-ecomorph relationship in anoles." The reference `@hagey2017there` is just inserted at the beginning of the sentence as in the following:

```
@hagey2017there studied the hindlimb-ecomorph relationship in anoles.
```

However, Harvard-like convention follows that if we aren't explicit about the study, we include the entire reference in parentheses. For instance, if we wanted to write, "A recent study considered the hindlimb-ecomorph relationship in anoles [@hagey2017there]." we would include the following:

```
A recent study considered the hindlimb-ecomorph relationship in anoles [@hagey2017there].
```
Note that `@hagey2017there` is wrapped in `[]`.

In R Markdown, bibliographies will be placed at the end of the document. Normally, this means you want to end your document with the header "References". This will anchor the bibliography in this section.


Note that this .bib file can be used in all your .Rmd documents, not just this one. As long as all the BibTex entries have unique keys, this .bib file can serve as a reference database for all your .Rmd citations.


<div class = "green">
<div class="row">
  <div class="col-sm-2"><a class="far fa-sticky-note fa-5x" style="color:#939681"></a> <!-- regular style --></div>
  <div class="col-sm-9">

You may be wondering where you can find BibTex citations. Like so much of our lives, the answer points to Google, specifically Google Scholar. As an example, go to [Google Scholar](http://scholar.google.com/) and search for the @hagey2017there paper. The entry under scholar will look like the following:

![](scholar1.png)
<br>

Click on the big `"` at the bottom of the entry. This will bring you to a pop-up window that contains different citation formats for the entry. 


![](scholar2.png)
<br>

Now click on the "BibTex" link at the bottom of the window. This will lead you to a text file of the BibTex format. Simply copy and paste this to your .bib file. Voila.

</div>
</div>
</div>
<br>


# Project Report

The goal of this project report is to produce an R Markdown in HTML that includes all the important components of the project reports you'll produce in Phases I and II of the course. You can think of this as a template that can be used when writing writing up your reports in all the subsequent modules. 


For this project report, write an .Rmd document named "TEAMNAME_Module4.R" that includes the following:
  
  1. A YAML header that specifies the author, title, date, output, and bibliography file. 
  2. The following section headers that organize your text and includes 2-3 short relevant sentences:
      + Introduction: Include a brief background to the anole project (why are we studying this anyway?), what the main questions is, and how this question will be answered.
      + Methods: Briefly outline the specifics of how the question will be answered.
      + Results: Briefly summarize the results.
      + Discussion: Briefly discuss the importance of the results (i.e., how they relate to the main question).
      + Author Contributions: Briefly state what the contributions of each team member to the project.
      + References: Populate a bibliography section that includes the works cited in the text.
  3. A centered image from an online source of an *Anolis* lizard at the end of the introduction. Please make sure this is in the [creative commons](reativecommons.org).]
  4. All the code chunks included in the [Adding Code with Chunks][Adding Code with Chunks] section.
  5. An altered  "AIC" chunk that produces a table of AIC values with `kable`. Be sure to include a descriptive caption 
  6. Another chunk of code, inserted before the "plot residuals" chunk, that produces a figure of a regression plot of log-transformed `HTotal` vs `SVL` with points colored by `Ecomorph2`. Be sure to include a descriptive caption here, too. 
  7. A citation to the @hagey2017there paper in the introduction (include in the References section, too) 
  8. A citation in the methods sections that identifies the source of the phylogenetic tree used in PGLS analysis (include in the References section as well).


Submissions are due by 11:59 PM on Sunday, October 4th. Submission can be uploaded [here](https://forms.gle/jaSZs4NPxr8Bf8yq9).

```{r,include=FALSE}
anole.phylo.aic <- AICc(pgls.BM1,pgls.BM2,pgls.OU1,pgls.OU2)
anole.phylo.aicw <- aicw(anole.phylo.aic$AICc)
rownames(anole.phylo.aicw) <- c("pgls.BM1","pgls.BM2","pgls.OU1","pgls.OU2")

anole.phylo.aicw%>%
  kable()
```

# References



