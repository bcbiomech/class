---
title: 'Miniproject 1: Open Sourcery'
---

# Introduction 

Welcome to the first Mini Project of BIOL 5380. The focus of this MP will be learn the basics of simple scripting and report writing. For our scripting work, we'll learn how to load, organize and summarize data, and produce simple figures. While we learn some ins and outs of simple data operations, we'll also learn how one can organize, share, and communicate results and ideas. 

Our tasks will be to:

  1. Familiarize ourselves with the R and R Markdown frameworks.
  2. Author a simple R Markdown.
  3. Run code within an R Markdown document.
  4. Add graphics (i.e., figures), to an R Markdown document. 
  5. Render (i.e., knit) this R Markdown into HTML documents.
  
## Buckle Up!

I'll be honest, for many of us just getting into this sort of thing, the learning curve is steep (see below). You'll be on the ascending limb of this curve for a while, but once you get over the hump, you'll be on its descending limb. I promise that eventually the time you invest in learning how to work in R will decrease your overall effort compared to where you started. So, just sit back, take it all in and rest assured you're making a great investment. 

```{r,echo=FALSE,fig.cap="The R coding learning curve.",fig.height=.8}
library(tidyverse)
library(scales)

x <- seq(0, 1, length = 1000)
t <- rbeta(1000,shape1=3,shape2=5)
h <- hist(t,plot = F)
xfit<-seq(min(t),max(t),length=1000)
yfit<-dbeta(xfit,2,5)
yfit <- rescale(yfit*diff(h$mids[1:2])*length(t),to=c(10,100))
qplot(xfit, yfit)+theme_classic(20)+xlab("time")+ylab("% effort")+ylim(c(0,100))+theme(axis.text.x = element_blank())

```

## First Principles 


R Studio's [markdown tutorial](https://rmarkdown.rstudio.com/) [Read Introduction to Output Formats]

As you learn more about R Markdown, you may want to reference the following online resources:

  * A rather [complete guide to R Markdown by Yikui Xie](https://github.com/rstudio/bookdown)
  * R Markdown [Cheatsheets](https://rmarkdown.rstudio.com/lesson-15.html)


# Part I: Establishing a Work Space

## Working in Directories

Before we set up our workspace in R Studio, let's discuss where we'll store important files you'll need for this project. This will establish a framework for other Mini Projects in the course.

First, we should establish a directory (i.e., folder) where we intend to store these files. Go ahead and do that, perhaps with the logical title "MP1". When we start work in R Studio and create a Markdown, we'll store the Markdown document in this folder. For each project, we'll use a single R Markdown file to save and execute code and generate a slick report. The code in a Markdown looks to the directory in which it is stored when that code requires input (e.g., data) or outputs (e.g., save plots and reports). In more technical parlance, the working directory is the parent directory of the Markdown document.

This has several important implications. First, this means that, unlike a simple script, you never have to tell R where to look for files or where to store them (i.e., set the working directory). This also means if you want your code in a Markdown to analyze data stored as a text file, you should make sure that this file is in the same directory as the Markdown document. 


For this project, we'll be working with jumping data from Prof. Kenaley's two children. You can download these files by clicking [here](data/OZ_jumping.zip).
## The R Studio IDE

R Studio is an Integrative Development Environment (IDE), that is, software that puts all that R can do on one screen. It is worth noting that **R Studio is not R**. In other words, R Studio helps you run R and see it's outputs and inputs. When you first start R Studio, you must have R installed.

Open R Studio and have a look at the arrangement of the windows. By default, there are four of these (see below):

  1. Code editor: This is where one edits code (a script, Markdown document, etc., i.e., where you store your R commands).
  2. The console (also terminal and R Markdown monitor): This is where you see the what's passed to R when your run code in the editor.
  3. Workspace and Environment: Tabs in this window describe what variables have been created and the history of the operations passed to the console.
  4. Plots, files, and help: Tabs in this window show the graphics that are produced from plotting commands, the files in a local directory (i.e., folder), packages (i.e., groups of functions) that are loaded, and help files that describe R functions.

```{r,echo=FALSE,out.width=550, fig.cap="R Studio window arrangement."}
#stride length
knitr::include_graphics("https://lh3.googleusercontent.com/proxy/0obSbSp9iXrPYsLwkro-vWJidhrJdKRPK1btUG9A3FOtz_-bLKO3t1664zvhYmLk297PZbbhtFyTG76AIw9kDaaXN6hg5fn5AHQ")

```

To get a sense of how this windows work together, open a new R script file with "File->New->"R script". There may be one loaded when you open R Studio. If so, ignore this step. You'll see a tab in the editor window titled "Untitled.R". This file is a simple text file where you can store commands. 

Now, type in the following text:

```{r,eval=FALSE}
data("cars")
```

Then, put your cursor at the end of the line or select the entire line and punch in **cmd+return** on a Mac or **ctrl+enter** on a PC. **This will run this line of code***. Now look at the history tab in the upper right and the console tab in the lower left. You should see `data("cars")`. This means that you've told R to load the data set `cars`, data for the speed of cars and the distances taken to stop that are buried in all R installs.

Now type in the following **in the console**. 
```{r,eval=FALSE}
?cars
```

Notice that a documentation entry pops up in the help tab in the lower right. Help pages like this are enormously helpful when you want to know more about any function, data set, or package loaded into R. Be sure to use this resource early and often.

Do something similar to find out what the `plot()` function is all about. Type this into the console.

```{r,eval=FALSE}
?plot()
```

Notice you get a few topics in the help tab. Click on "Generic X-Y Plotting" to see what this function in base R requires and can do. 

Next, go ahead and add this line to the R script:

```{r,eval=FALSE}
print(cars)
```
Notice how the `cars` data frame is printed to the console. There are two columns, `speed` and `dist`. Let's now plot `dist` vs. `speed` using `plot()`. So now add the following to script and run this new line: 

```{r}
plot(cars$speed,cars$dist)
```

You'll see a plot identical to the one above in the "Plots" tab. As we'll learn in a bit, data frames with named columns (and other variable types with named vectors) can be subsetted with `$`. Go over to the upper right window and click on the "Environment" tab. Under "Data", you'll see the variable "cars" described. Click on it and this will pass a `View()` command to the R console which, in turn, will add a tab in the upper left with the tittle "cars". This tab contains a row-by-column representation of the data.

So far, you've run the commands in each line by selecting and punching in *cmd+return** or **ctrl+enter** key strokes. This is a handy way to run each line as you add it to your code. You can also run all the code at once by selecting all the text and keying in *cmd+return** or **ctrl+enter**. Every operation encoded in these lines will unfold in order. 

From this quick exploration of how R works in R Studio, we should note few important things:

  1. Commands for R to process are stored in text files that appear in the editor window.
  2. The console shows what's been run by R.
  3. Commands can be run in the console, but aren't saved in the script file.
  4. The "Help" and "Environment" tabs are useful resources for seeing what's under the hood of your R environment.
  5. Plots and other graphics appear in the "Plots" tab.



## Working with R in Markdown

Although we've just learned how commands are passed through R in R Studio by using a script file, we won't use these simple files in the class. They contain only code. While they may produce important things like plots and the results of calculations, they're not very easy to read and don't provide any narrative. As an alternative to writing code in one place and about the results of the code in another, we'll combine our code and narratives in one document: an R Markdown (or .Rmd file). That is, you can use a single R Markdown file to both save and execute code and generate high quality reports that can be shared with an audience.
 
So let's begin our Markdown odyssey with opening a new .Rmd file with "File->New->R Markdown".


```{r,echo=FALSE,out.width=550}
#stride length
knitr::include_graphics("img/newRmd.png")

```

In the title box, enter "MP1" and your name in the author box, then click ok. You'll see and untitled .Rmd appear in the upper left window. Save this to yout "MP1" diectory. Let's now have a look at what's in this text file. 

## The YAML Header

You'll see at the top of your new ".Rmd" file a header contained between two lines (`---`). This is the YAML header that specifies the attributes of the markdown, all of which are inherited from the dialog your answered when opening the new .Rmd. By default it includes a title, author, date, and type of file for your output. These are but a few of the formatting options and settings that could apply to the whole document. For now, let's leave it as is. So it should look like this:

```
---
title: "MP1"
author: Your Name
date: 5/Feb/2021
output: html_document
---
```

Below the YAML header is the space where you'll include text, code, etc. 

## knitting Cozy Reports

In the .Rmd before us, we have a template with some marked up text. This is the file that will be interpreted by the Markdown language to produce a document. To do so, you must "knit" the .Rmd. You can do this by selecting the "knit" icon at the top of the file panel or keying in **cmd+shift+k**. Go ahead and do either and see what happens. You'll get an HTML rendering of your document. You may end up doing this often as you add new pieces and markup to the text. Notice that there's now an .html file saved to the same directory (i.e., folder) containing the .Rmd file. You can see this in the "Files" tab in the lower right window.

Notice the following components:

  + Headers: Text marked with `#`'s that indicate sections.
  + Code chunks: code text wrapped in "**```**", the fist instance of which is appended with `{r...}`. These sections run the code within them.

## Headers

When you start putting together the content of an .Rmd, you should consider adding sections almost immediately. This can serve as an outline for the document. Headers provide a way of hierarchically organizing the document into sections that reflect an outline. These are identified in the markdown by using one or several `#`. The more you use, the smaller the text and, presumably the less inclusive the header. That is, `#` is the biggest header and `##` is typically nested within a `#` header, and `###` is nested within a `##` header. For instance, this 

```
# Header 1

Text under Header 1

## Header 2

Text under Header 2

### Header 3

Text under Header 3

```
will produce this:
```{r,echo=FALSE,out.width=550}
#stride length
knitr::include_graphics("img/headers.png")

```


In your future project reports, you'll always want to include sections for an introduction, methods, results, discussion, author contributions, and references. We'll organize the .Rmd accordingly, so please add those sections to your .Rmd. with a high-level header `#`.  You can add  nested subsections and text as needed later.  

## Adding and Running Code with Chunks

Code you include in your .Rmd should be written in sections enclosed by three backwards apostrophes (```). These sections are known as code chunks and look like this:

```{r,echo=FALSE,out.width=550}
#stride length
knitr::include_graphics("img/chunk.png")

```


You can insert code chunks  by selecting the "insert" icon at the top of the the tab, by keying in **cmd+opt+i**, or simply typing those "```".

To run the chunk, your can  click on "run" icon at the top of R studio and select "Run Current Chunk". Alternatively, you can click on the green icon that looks like a play button/tringle (see below) or insert your cursor in the chunk and key in **cmd+shift+return**. 

```{r,echo=FALSE,out.width=550}
#stride length
knitr::include_graphics("img/runchunk.png")

```

The content inside the curly brackets (`{}`) controls the behavior of code chunk. In this case, we're telling R markdown that the code inside the chunk is to be interpreted with R. This is a handy place to control the output of the code chunk. Let's jump right into how you would include code in chunks in the context of this simple project. 

At first, you'll want to include a chunk that loads the libraries you intend to use in the .Rmd. Libraries are stored as packages and only a few are included in the R install. We'll use several packages that need to be downloaded and installed. Fortunately, they're all wrapped in one superpackage, `tidyverse`. Go to the "Packages" tab in the lower right window and click on the "install" tab. When you do that, you'll see a prompt appear like the one below.

```{r,echo=FALSE,out.width=350}
#stride length
knitr::include_graphics("img/install.png")

```

In the "packages" field, type in "tidyverse" and click "install". You'll see a bunch of red text appear in the console, indicating that the packages in `tidyverse` are being installed.


No you can add the following to the very top of the document:

<pre><code>```{r,include=FALSE}
library(tidyverse) #always
```</code> </pre>

Run this chunk to load `tidyverse`.

Notice here that we included a behavior to the chunk, specifically  `include=FALSE`. This prevents the code, and the results from appearing in the finished file. Have a look at [this page](https://rmarkdown.rstudio.com/lesson-3.html) to familiarize yourself with handy and often used chunk options.

With a few exceptions, the logical place to include the code that produces analyses or figures is in the results sections. This is where the first output of the code will likely be relevant. So, under the results section, insert the following code chunks that establish the data we need in the next section.


<pre><code>```{r, "load the data"}
anole <- read_csv("anole.dat.csv")
anole.eco <- read_csv("anole.eco.csv")
anole.tree <- read.tree("anole.tre")
```</code> </pre>

```{r, "load the data"}

```


## Section on running code 

  + line by line
  + knit
  + they are sequential
  
## Got to data carpentry after my intro.
dont' worry about section on saving data. Run the examples in R chunks. 
https://datacarpentry.org/R-ecology-lesson/01-intro-to-r.html
# Part I: R Coding Basics



```{r,eval=FALSE}
#on a mac
setwd("~/Documents/BC/5380.s.2018/MP1")

#on a pc
#setwd("C:\\Users\\user\\Documents\\BC\\5380.s.2018\\MP1")
```

Note, this is unique to each user. You can pull up the file info with your operating system and copy the directory and paste it within quotes of the `setwd()` command. Select the line and run the the `setwd()` command. 

Now, let's load the data and check that it read with (remember, `<-` is R speak for pass the stuff to the right to a variable name on the left):

```{r,eval=FALSE}
dat <- read.csv("OZ_jumping_1.csv") #read the data from the comma-separated file 
head (dat) #print the first few rows to the monitor
```

OK, data loaded. Congrats! The `head()` command prints the first few rows, showing that the data include `o` for Ollie's data and `z` for Zoe's vertical displacement and `t` for time in milliseconds (ms), Now, let's plot some of the data, say for Zoe, with the simple graphics packages and `with()` command loaded with R. The `with()` call says, "R, with the data `dat`, plot a scatterplot of `z` versus `t`."

```{r, echo=FALSE,eval=FALSE}
with(dat,plot(t,z)) #the with command say do with x something
```

Splenid! But what about poor Ollie?!? We could add his points with the following `points()` call. The color parameter (`col`) is added with `red` to distinguish the two jumpers.

```{r,eval=FALSE}
with(dat,plot(t,z))
with(dat,points(t,o,col="purple"))
```

Even better! OK, but don't we want to know more about this experiment, like say who jumped highest? How would we answer that? Well, perhaps something like this would help:


```{r,eval=FALSE}
max.o <- max(dat$o)
max.z <- max(dat$z)

max.jump <- c(max.o,max.z)
names(max.jump) <- c("o","z")
print(max.jump)
```
`print()` prints something to the terminal and the `c()` command combines two or more things and the `names()` command gives a vector (a one-dimensional series) its names (notice the two must be the same length) 

So that's all well and good. It looks like Zoe jumped a littler higher. But, by how much? That's simple to calculate. To do this, we'll make turn these summary statistics into a two-dimensional data frame (like a spreadsheet), with the `data.frame()` function.

```{r,eval=FALSE}
oz.stats <- data.frame(o=max.o,z=max.z)
oz.stats$diff <- abs(oz.stats[,"o"]-oz.stats[,"z"])
print(oz.stats)
```


Notice how we are able to subset the data by column name with brackets. Within the brackets, anything to the right of a comma references columns and anything to the left rows. So we select columns that equal `o` and `z` and then take the absolute value of one subracted from the other with the `abs()` call. 


# Whole 'nutha level
Spectacular! However, it's a little cumbersome. There is, indeed, a little more streamlined way to do this with slightly more sophisticated data maniplulation and plotting that produces much more pleasing results and a workflow that can be manipulated with ease. Let's first install and then load some packages that make for easy data manipulation and wonderful plot making.

Let's go back to the original data and melt it, that is, rather than have seperate columns for the vertical displacement data for `o` and `z`, let's have them in one and identify in another column to whom the data belong. This is super easy with the `melt()` function from `reshape2`. Then we can use the amazingly simple and beautiful plotting commands from `ggplot` to plot the data with a color according to the variable (which kiddo).

```{r,eval=FALSE}
dat.m <- melt(dat,id= "t")
head(dat.m)
tail(dat.m)

qplot(x=t,y=value,dat=dat.m,col=variable) #a quick plot with ggplot
```

Super easy and concise. What about those summary statistics? Just as easy with the `ddply` function in the `plyr` package . . . 

```{r,eval=FALSE}
dat.sum <- ddply(dat.m,.(variable),summarize,max=max(value),min=min(value),max=max(value),n=length(value))
head(dat.sum)
tail(dat.sum)

qplot(x=variable,y=max,dat=dat.sum,col=variable,size=4)
```

# Loop `if` you can

One of the most magical aspects of command-line computing (i.e., what you're doing right now) is that one can automate the mundane. Imagine that instead of just one jumping experiment, you ran 5 separate jumping expirements with these two goofballs and had digitized data from each. Now that's 5 replicates and worthy of some comprehensive analysis. For the record, 5 is generally seen as the magic minimum number of replicates in biomechanics. Assuming all the replicates result in the same raw data---vertical displacement of `o` and `z` and `t` in milliseconds, this should be relatively straigtforward. Think for a moment about how you would go about this. Would you somehow get these data into Excel and add another column column indicating the replicate? You could do that, but that's slow and, as with so many manual operations in computing, often results in errors. Due to these factors and, as importantly, the ethos of BIOL5380, let's avoid using commercial software with all its limitations. But where to begin? Enter the `for` loop. 

What is a `for` loop you ask? It's a command that runs while a condition is satisfied. For example, how 'bout we print a count down thusly:

```{r}
cnt <- 10:1 #store some numbers

for(i in cnt){
  print(paste("It's now", i))
}

```

The operations contained in the `for` command (within the `"{ }"`) are repeated through the series defined by `cnt`. Specifically, for each value in `i`, `paste()` together `"It's now"` and `i` and `print()` it.

Now that we have a basic understanding of how this works, let's apply it to our problem: automating the combining of a bunch of data. The crux here is that each of our 5 jumping trials are contained in their own files. Go ahead and download the remaining files and move them to your working directory:

<http://www2.bc.edu/christopher-kenaley/bio5380/MP1/OZ_jumping_2.csv>

<http://www2.bc.edu/christopher-kenaley/bio5380/MP1/OZ_jumping_3.csv>

<http://www2.bc.edu/christopher-kenaley/bio5380/MP1/OZ_jumping_4.csv>

<http://www2.bc.edu/christopher-kenaley/bio5380/MP1/OZ_jumping_5.csv>

Now have a look at your files in the directory with this: 


```{r}
list.files()

```

Notice something about the file name structure? They are all named with a simple convention, that is, they all end in `_number.csv.` This number indicates the replicate (1 was the first, 5 was the last). With a standard convention like this, we can use a `for` loop to read in each file and extract from the file name from what replicate the data come. Let's walk through it. First, store the file names of interest:

```{r}
dat.files <- list.files(pattern=".csv")

```

This saves the names of all the files with the pattern `.csv` to the variable name `dat.files`. Now, let's use the for loop to read each file and save it to a list of data frames. 

```{r,eval=FALSE}

all.dat <- list() #establish an empty list
for (i in dat.files ){
  meta.dat <- strsplit(i,"_")[[1]] #store the metadata by splitting the file name
  if(grepl("OZ",i)) print("YES") 
  rep <- gsub(".csv","",meta.dat[3]) #use grep commands to remove the ".csv" at the end
  dat.i <- read.csv(i) #read in the data
  all.dat[[i]] <- data.frame(dat.i, rep=rep) #combine the data withe replicate number in a data frame and stor it in our list under the file name i
}
```

Phew, that was a lot, let's unpack it. The first line establishes a list named `all.dat` to receive our data. Then, the guts of `for` ensues. For all the `dat.files`, first retrieve the meta data, i.e., the data that explains your data, in this case the replicate number. We do this with the `strsplit()` command. It splits a text string by seperator, a `"_"` in this case. Notice that the command `strsplit(i,"_")` outputs a list itself. The tell here is the `[[1]]`, a "1" with the double brackets indicating such.

```{r,eval=FALSE}
strsplit(i,"_")
```

There's only one element in this list, but we still have to identify that's the one we want. Thus the `[[1]]` added to the `strsplit(i,"_")` command. Notice the third element in this is what we want, the replicate number. However, it has the unsightly "`.csv`" stuck to it. Let's zap that with a `gsub()` command. `gsub()` is one of a series of search commands common to all computing languages. These commands use  general regular expressions, or `regex`, in algorithms to find text. It's really powerful, but any in-depth explanation of how they work is way beyond the scope of this MP and the course (however, you can learn more [here](https://en.wikipedia.org/wiki/Regular_expression). `gsub()` finds a string and substitutes it with another. In our case, we want to find `".csv"` and replace it with `""`, that is, nothing. With `gsub(".csv","",meta.dat[3])` we do just this and store the result in `rep`.

Next, we read in the data and pass it to the variable `dat.i`. Then, we combine the data in a data frame with a new column called `rep` with the `rep` meta data. This gets passed to an item in the list `all.dat` with the name `i`. This proceeds for all the items in the `dat.files` variable. Viola! Now we have a list of named data frames. Have a look by typing `all.dat` into the terminal. Caution: R tries to print it all.


What's left is to simply combine all the data frames into a single data frame.

```{r,eval=FALSE}
all.dat <- do.call(rbind,all.dat)
```

What we did here is apply a function to all items in our list with the `do.call()` command. This says, "Bind the rows of all the data frames in the `all.dat` list with the command `rbind`." Double viola!! Have a look by printing the first few and last few rows of the new comprehensive data frame.

```{r,eval=FALSE}
head(all.dat)
tail(all.dat)
```

Wow, all our data from the five replicates in one spot. Now, we can apply some of the manipulation techniques we learned above to derive some summary statistics. So say we want to know the minimum, maximum, and number of data for each trial and for each kiddo:

```{r,eval=FALSE}
all.m <- melt(all.dat,id=c("rep","t")) #first melt the data frame
all.sum <- ddply(all.m,.(rep,variable),summarize,min=min(value),max=max(value),n=length(value)) #summarize the data by rep and variable (kiddo) and extract the min, max, and length (n)
```

Sweet! Easy peasy. Let's plot our results---the max vertical displacement---but this time save the plot itself to a variable `p`.

```{r,eval=FALSE}
p <- qplot(x=rep,y=max,dat=all.sum,col=variable)
print(p) #print p to see it
```

After saving the plot, we can add aspects to it using the `ggplot` language. For example, change the x- and y-axis labels and give the plot a clean, classic look with 20 pt font. Then, save the plot as a PDF:


```{r,eval=FALSE}
p <- p+ylab("y displacement (cm)")+xlab("time (ms)")+theme_classic(20)

pdf("y_disp_vs_t.pdf") #open a pdf
print(p) #print a plot to it
dev.off() #shut it down
```


Holy smokes, that looks spectacular! You're now armed with some kick-arse scripting and plotting skills to analyze and visualize data, biomechanical or otherwise.

# Your mission (and you have to accept it)

Now that you have some R skills, lets put them to the test. You're tasked with writing a markdown document using `knitr` in much the same way this document was produced. Yes, I'm throwing you to the wolves, but that's often what makes this stuff stick. You can start with details on using R Markdown at http://rmarkdown.rstudio.com **and** inspecting the contents of this file. This'll help, too: https://www.rstudio.com/wp-content/uploads/2015/02/rmarkdown-cheatsheet.pdf

The markdown must contain the following:

  1. A plot of the mean maximum for each kiddo across all replicates. It must contain or be accompanied with:
    + properly labelled axes
    + different colors for each subject
    + error bars that correspond to 1Â± standard error of the mean (s.e.)
    + a simple ANOVA test of results (with alpha of 0.05). [This'll help.](https://www.statmethods.net/stats/anova.html)
    + a brief paragraph summarizing the differences and any inferences of why they are
  2. A plot of the maximum vertical displacement for each kiddo versus replicate with a trend line. This must also be accompanied: 
    + a table and summary of a two-way ANOVA (i.e., analysis of covariance) that tests the differences between subjects as they vary with replicate. [This'll help.](https://rexplorations.wordpress.com/2015/09/07/two-way-anova-in-r/)
    + a brief paragraph summarizing the differences and any inferences of why they are
    
The `knitr` markdown file is due on January 29th at 11:00 Am. You should submit the file to this [google directory](https://drive.google.com/drive/folders/1XnpBl1sx1DJFnEq_ngMZIdUmEySCa-nZ?usp=sharing) by the start of class. 
  
  <b>Good luck!</b>



